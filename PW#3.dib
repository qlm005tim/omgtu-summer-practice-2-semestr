#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!csharp

//
// Вычисление определенного интеграла в несколько потоков и без потоков
//
using System.Threading;
class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений

    //Многопоточная программа
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        // отсюда надо начинать реализацию задачи
        double totalArea = 0;
        
        double partitionSize = (b - a) / threadsnumber;
        
        object lockObject = new object();
        ManualResetEvent barrier = new ManualResetEvent(false);
        int threadsFinished = 0;

        for (int i = 0; i < threadsnumber; i++)
        {
            
            double start = a + i * partitionSize;
            double end = start + partitionSize;

            new Thread(() =>
            {
                double localArea = 0;

                int traps = (int)Math.Ceiling((end - start) / step);
                for (int i = 0; i < traps; i++)
                {
                    double x1 = start + i * step;
                    double x2 = Math.Min(x1 + step, end);
                    double y1=function(x1);
                    double y2=function(x2);
                    localArea += (y1+y2) / 2 * (x2 - x1);
                }
                
                lock (lockObject)
                {
                    totalArea += localArea;
                }

                if (Interlocked.Increment(ref threadsFinished) == threadsnumber)
                    barrier.Set();
            }).Start();
        }

        barrier.WaitOne();
        return totalArea;
    }

    // Solve1 - вычисление без применения потоков
    
    public static double Solve1(double a, double b, Func<double, double> function, double step)
    {
        double area = 0.0;
        double len = b - a;
        int traps = (int)Math.Ceiling(len / step);
        for (int i = 0; i < traps; i++)
        {
            double x1 = a + i * step;
            double x2 = Math.Min(x1 + step, b);
            double y1=function(x1);
            double y2=function(x2);
            area += (y1+ y2) / 2 * (x2 - x1);
        }
        return area;
    }

}

#!csharp

//оптимальный шаг
#r "nuget: xunit, 2.8.1"

using Xunit;
using System.Diagnostics;
var SIN = (double x) => Math.Sin(x);
Stopwatch time = new Stopwatch();

double[] steps = { 1e-1, 1e-2, 1e-3, 1e-4 };

foreach (double step in steps)
{
    double time100=0;
    for (int i=0; i<100;i++)
    {
        time.Restart();
        Assert.Equal(0, DefiniteIntegral.Solve1(-100, 100, SIN, step), 1e-4);
        time.Stop();
        time100 += time.Elapsed.TotalMilliseconds;
    }
    Console.WriteLine($"Среднее время работы с шагом {step}: {time100/100} мс");
    
}

#!csharp

#r "nuget: xunit, 2.8.1"

using Xunit;

var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, X, 1e-4, 2), 1e-4);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, SIN, 1e-5, 8), 1e-4);

Assert.Equal(50, DefiniteIntegral.Solve(0, 10, X, 1e-6, 8), 1e-5);
